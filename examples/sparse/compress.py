# Useful functions related to sparse bitarray compression.
# In particular the function sc_stats() which returns the
# frequency of each block type.

from collections import Counter
from itertools import islice
from random import random, randint

from bitarray import bitarray
from bitarray.util import sc_encode, sc_decode


def read_n(n, stream):
    i = 0
    for j in range(n):
        c = next(stream)
        i |= c << 8 * j
    if i < 0:
        raise ValueError("read %d bytes got negative value: %d" % (n, i))
    return i

def sc_decode_header(stream):
    head = next(stream)
    endian = 'big' if head & 0x10 else 'little'
    length = head & 0x0f
    if head & 0xe0 or length > 8:
        raise ValueError("invalid header: 0x%02x" % head)

    nbits = read_n(length, stream)
    return endian, nbits

def sc_decode_block(stream, stats):
    head = next(stream)
    if head == 0:  # stop byte
        return False

    if head <= 128:
        n = 0
        k = head
        assert 0 < k <= 128
    elif 160 <= head < 192:
        n = 1
        k = head - 160
        assert k < 32
    elif 192 <= head <= 194:
        n = head - 190
        k = next(stream)
    else:
        raise ValueError("Invalid block head: 0x%02x" % head)

    stats['blocks'][n] += 1

    # consume block data
    bytes(islice(stream, max(1, n) * k))
    return True

def sc_stats(stream):
    """sc_stats(stream) -> dict

Decode a compressed byte stream (generated by `sc_encode()` and return
useful statistics.  In particular, the frequency of each block type.
"""
    stream = iter(stream)
    endian, nbits = sc_decode_header(stream)

    stats = {
        'endian': endian,
        'nbits': nbits,
        'blocks': Counter()
    }

    while sc_decode_block(stream, stats):
        pass

    stop = False
    try:
        next(stream)
    except StopIteration:
        stop = True
    assert stop

    return stats

def random_array(n, p = 0.5):
    if p < 0.01:
        a = bitarray(n)
        a.setall(0)
        for _ in range(int(p * n)):
            a[randint(0, n - 1)] = 1
        return a

    return bitarray((random() < p for _ in range(n)))


if __name__ == '__main__':
    a = bitarray(1<<33)
    a.setall(0)
    a[:1<<16] = 1
    a[:1<<18:1<<4] = 1
    a[:1<<22:1<<12] = 1
    a[:1<<30:1<<20] = 1
    print(len(a), a.count())
    b = sc_encode(a)
    print(len(b))
    res = sc_stats(b)
    for n in range(5):
        print("block type %d  %8d" % (n, res['blocks'][n]))
    assert a == sc_decode(b)
