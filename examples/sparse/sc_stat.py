from itertools import islice


def read_n(n, stream):
    i = 0
    for j in range(n):
        i |= next(stream) << 8 * j
    if i < 0:
        raise ValueError("read %d bytes got negative value: %d" % (n, i))
    return i

def sc_decode_header(stream):
    head = next(stream)
    if head & 0xe0:
        raise ValueError("invalid header: 0x%02x" % head)
    endian = 'big' if head & 0x10 else 'little'
    length = head & 0x0f
    nbits = read_n(length, stream)
    return endian, nbits

def sc_decode_block(stream, stats):
    head = next(stream)
    if head == 0:  # stop byte
        return False

    if head < 0xa0:
        n = 0
        k = head if head <= 32 else 32 * (head - 31)
    elif head < 0xc0:
        n = 1
        k = head - 0xa0
    elif 0xc2 <= head <= 0xc4:
        n = head - 0xc0
        k = next(stream)
    else:
        raise ValueError("Invalid block head: 0x%02x" % head)

    stats['blocks'][n] += 1

    # consume block data
    size = max(1, n) * k        # size of block data
    next(islice(stream, size, size), None)

    return True

def sc_stat(stream):
    """sc_stat(stream) -> dict

Decode a compressed byte stream (generated by `sc_encode()` and return
useful statistics.  In particular, a list of length 5 with the count for
each block type.
"""
    stream = iter(stream)
    endian, nbits = sc_decode_header(stream)

    stats = {'endian': endian,
             'nbits': nbits,
             'blocks': 5 * [0]}

    while sc_decode_block(stream, stats):
        pass

    return stats

# ---------------------------------------------------------------------------

import unittest

from bitarray import bitarray
from bitarray.util import sc_encode, sc_decode


class Tests(unittest.TestCase):

    def test_empty(self):
        blob = b"\x01\x00\x00"
        self.assertEqual(sc_stat(blob),
                         {'endian': 'little',
                          'nbits': 0,
                          'blocks': [0, 0, 0, 0, 0]})
        self.assertEqual(sc_decode(blob), bitarray())

    def test_explitcit(self):
        for blob, blocks in [
                (b"\x11\x08\x00",         [0, 0, 0, 0, 0]),
                (b"\x11\x08\x01\x00\x00", [1, 0, 0, 0, 0]),
                (b"\x11\x08\xa0\x00",     [0, 1, 0, 0, 0]),
                (b"\x11\x08\xc2\x00\x00", [0, 0, 1, 0, 0]),
                (b"\x11\x08\xc3\x00\x00", [0, 0, 0, 1, 0]),
                (b"\x11\x08\xc4\x00\x00", [0, 0, 0, 0, 1]),
        ]:
            stat = sc_stat(blob)
            self.assertEqual(stat['blocks'], blocks)
            a = sc_decode(blob)
            self.assertEqual(len(a), 8)
            self.assertFalse(a.any())

    def test_untouch(self):
        stream = iter(b"\x01\x03\x01\x03\0XYZ")
        sc_decode(stream)
        self.assertEqual(next(stream), ord('X'))

    def test_end_of_stream(self):
        for blob in [b'', b'\x00', b'\x01', b'\x02\x77',
                     b'\x01\x04\x01', b'\x01\x04\xa1', b'\x01\x04\xa0']:
            self.assertRaises(StopIteration, sc_stat, blob)

    def test_values(self):
        b = [0x11, 3, 1, 32, 0]
        self.assertEqual(sc_decode(b), bitarray("001"))
        self.assertEqual(sc_stat(b), {'endian': 'big',
                                      'nbits': 3,
                                      'blocks': [1, 0, 0, 0, 0]})
        for x in -1, 256:
            b[-1] = x
            self.assertRaises(ValueError, sc_stat, b)

    def test_example(self):
        n = 1 << 26
        a = bitarray(n, 'little')
        a[:1 << 16] = 1
        for i in range(2, 1 << 16):
            a[n // i] = 1
        b = sc_encode(a)
        self.assertEqual(sc_stat(b),
                         {'endian': 'little',
                          'nbits': n,
                          'blocks': [2, 147, 3, 1, 1]})
        self.assertEqual(a, sc_decode(b))


if __name__ == '__main__':
    unittest.main()
