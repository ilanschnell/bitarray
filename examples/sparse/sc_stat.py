from itertools import islice
import unittest

from bitarray import bitarray
from bitarray.util import sc_encode, sc_decode


def read_n(n, stream):
    i = 0
    for j in range(n):
        i |= next(stream) << 8 * j
    if i < 0:
        raise ValueError("read %d bytes got negative value: %d" % (n, i))
    return i

def sc_decode_header(stream):
    head = next(stream)
    if head & 0xe0:
        raise ValueError("invalid header: 0x%02x" % head)
    endian = 'big' if head & 0x10 else 'little'
    length = head & 0x0f
    nbits = read_n(length, stream)
    return endian, nbits

def sc_decode_block(stream, stats):
    head = next(stream)
    if head == 0:  # stop byte
        return False

    if head < 0xa0:
        n = 0
        k = head if head <= 32 else 32 * (head - 31)
    elif head < 0xc0:
        n = 1
        k = head - 0xa0
    elif 0xc2 <= head <= 0xc4:
        n = head - 0xc0
        k = next(stream)
    else:
        raise ValueError("Invalid block head: 0x%02x" % head)

    stats['blocks'][n] += 1

    # consume block data
    size = max(1, n) * k        # size of block data
    next(islice(stream, size, size), None)

    return True

def sc_stat(stream):
    """sc_stat(stream) -> dict

Decode a compressed byte stream (generated by `sc_encode()` and return
useful statistics.  In particular, a list of length 5 with the count for
each block type.
"""
    stream = iter(stream)
    endian, nbits = sc_decode_header(stream)

    stats = {'endian': endian,
             'nbits': nbits,
             'blocks': 5 * [0]}

    while sc_decode_block(stream, stats):
        pass

    return stats


class Tests(unittest.TestCase):

    def test_empty(self):
        a = bitarray(0, 'big')
        self.assertEqual(sc_stat(sc_encode(a)),
                         {'endian': 'big',
                          'nbits': 0,
                          'blocks': [0, 0, 0, 0, 0]})

    def test_example(self):
        a = bitarray(1 << 33, 'little')
        a[:1<<16] = 1
        a[:1<<18:1<<4] = 1
        a[:1<<22:1<<12] = 1
        a[:1<<30:1<<20] = 1
        self.assertEqual(a.count(), 79804)
        b = sc_encode(a)
        self.assertEqual(sc_stat(b),
                         {'endian': 'little',
                          'nbits': 1 << 33,
                          'blocks': [2, 754, 46, 48, 1]})
        self.assertEqual(a, sc_decode(b))


if __name__ == '__main__':
    unittest.main()
